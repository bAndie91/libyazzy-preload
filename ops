{"author":{"id":"737a8210ad15a3b0faa813f350fa083d2c3cb4d6d580d8596bbc3c526756758c"},"ops":[{"type":1,"timestamp":1737370160,"nonce":"frAdYbDE0pePOrRMTz1S8nUOGRo=","title":"parse size limit","message":"https://github.com/bAndie91/libyazzy-preload/blob/3f3ccaa4bfe5ab24b5f51c0df38af68389b0e370/src/recyclix.c#L478\n\n\u003e snprintf(number, 16\u003edigits+1 ? digits+1 : 16, \"%s\", str+num_start);\n\nShould just be:\n\n\u003e snprintf(number, sizeof number, \"%s\", str + num_start);\n\nThere is no benefit in calculating a more stringent limit than the size of the destination buffer.\nIf the value returned by snprintf is \u003e= sizeof number, then truncation took place.\n\n\u003e size = atoi(number);\n\natoi won't handle 15 digit numbers (your int is 32 bits wide), and has no error checking, only undefined behavior on overflow. You want `strtoll`. Or perhaps `strtoull`.\n\nvia https://www.reddit.com/r/linux/comments/9vlrhp/transparent_recycle_bin_for_base_linux/e9dsj1t/","files":null}]}